<html>
	<body>
<title>Profiling Report and Optimizations</title>
<style>
	 .cent{text-align:center; margin-left:auto; margin-right:auto;}
	 .eqn{text-align:center; font-size: 20px; margin-left:auto; margin-right:auto;}
	 pre{text-align:left; font-size: 16px; padding:25px; background-color:#eee}
	 p{text-align:left; margin-left:auto; margin-right:auto;font-size: 21px;}
	 li{margin-left:auto; margin-right:auto;font-size: 21px;}
</style>
<div class = "cent">
<h1>Plot Analysis of the code</h1>
</div><br>
<p>For analysing code for using it for optimization etc., we stopped the GLUI and GLUT calls. Since, the mechanism of our cycle was moslty keyboard oriented, we set the angular velocity and the linear velocity of the bicycle to a constant and generated csv data containing various time involved in the process. The data was analysed using mat </p>
<hr><div class = "cent">
<h2>Plot 1: Loop time and average step time vs iteration values</h2>
</div>
<p>Loop time increases with the number of iterations. As iteration number increases there will be more number of ‘for’ loop execution and with each for loop initiating 150 steps. </p>
<div class = "eqn">
t_{step}=<i>(x)</i>/()y*itr}{itr}=<i>()</i>/()</div>
<div class = "cent">
<img src="./../doc/images/plots/plot01.png" align="middle"height="450px" width="600px"> <br>
Loop time and average step time vs iteration values</div>
<br>
<hr><div class = "cent">
<h2>Plot 2: Average step, collision, velocity and position update times vs iteration values</h2>
</div>
<div class = "cent">
<img src="./../doc/images/plots/plot02.png" align="middle"height="450px" width="600px"> <br>
Average step, collision, velocity, position and loop time vs iteration value</div>
<br>
<hr><div class = "cent">
<h2>Plot3 : Average step time with error bars v/s iteration value</h2>
</div>
<p>Plot step time line graph with error bars and deviation as maximum and minimum value for all reruns in particular iteration Deviation keeps on gradually decreasing with increase in iteration. This is because:- <br></p>
<div class = "eqn">
error= &Delta; <i>(x)</i>/()y*iter}{itr}=<i>( &Delta; x)</i>/() &Delta; y</div>
<div class = "cent">
<img src="./../doc/images/plots/plot03.png" align="middle"height="450px" width="600px"> <br>
Average step time with error bars v/s iteration value</div>
<br>
<hr><div class = "cent">
<h2>Plot4 : Frequency and Cumulative Frequency Plot of Step Time</h2>
</div>
<p>From the frequency plot of the step time, the most probable step time value (x-axis) can be found (by the plot below) </p>
<div class = "cent">
<img src="./../doc/images/plots/plot04.png" align="middle"height="450px" width="600px"> <br>
Frequency and Cumulative Frequency Plot of Step Time</div>
<br>
<hr><div class = "cent">
<h2>Plot 5 : Best Linear fit for Step Time vs Iteration Value</h2>
</div>
<p>As the step time varies slightly for all reruns for a particular iteration value thus the random points "blue" and average point "red" become close to each other (with slight deviation in slopes of best fit line). </p>
<div class = "cent">
<img src="./../doc/images/plots/plot05.png" align="middle"height="450px" width="600px"> <br>
Best Linear fit for Step Time vs Iteration Value</div>
<br>
<hr><div class = "cent">
<h2>Profiling and Optimization</h2>
</div>
<p></p>
<hr><div class = "cent">
<h2>Step I :- Optimizing functions that take large time</h2>
</div>
<p>With the help of profiling data generated by gprof, we opt the functions which were taking large time. These functions in our simulation were b2ContactSolver::SolveVelocityConstraints() and b2RevoluteJoint:: SolvePositionConstraints(b2SolverData ) These functions were mostly used by the chain and pedal system as the chain joints were made using Revolute joints. So, we changed various features related to them like the length of a chain element and the friction coefficient of the chain. </p>
<hr><div class = "cent">
<h2>Optimization by varying the size of the chain element</h2>
</div>
<p>The chain is made of various small elements and joined by Revolute joints. Initially we kept the length of a chain element as 1.0f As shown in Figure 1, the b2ContactSolver function takes the major chunk of time and also, there are a lot functions taking larger time. </p>
<div class = "cent">
<img src="./../doc/images/chain1.png" align="middle"height="400px" width="800px"> <br>
Figure 1: Profiling Data with chain element length as 1.0f</div>
<br>
<div class = "cent">
<img src="./../doc/images/chain6.png" align="middle"height="400px" width="800px"> <br>
Figure 2: Profiling Data with chain element length as 0.6f</div>
<br>
<div class = "cent">
<img src="./../doc/images/chain4.png" align="middle"height="400px" width="800px"> <br>
Figure 3: Profiling Data with chain element length as 0.4f</div>
<br>
<hr><div class = "cent">
<h2>Optimization by adjusting the friction values between various elements</h2>
</div>
<p>The second significant change that was observed was when the friction value of the chain elements was changed from 10.f (initial value) till 30.0f (final value). A decrease in cumulative time of all functions was observed to decrease from 0.27 units to 0.21 units. Also the time required by above two described functions decreased. </p>
<div class = "cent">
<img src="./../doc/images/friction10.png" align="middle"height="400px" width="800px"> <br>
Figure 4: Profiling Data with friction value 0f chain as 10.0f</div>
<br>
<div class = "cent">
<img src="./../doc/images/friction10.png" align="middle"height="400px" width="800px"> <br>
Figure 5: Profiling Data with friction value 0f chain as 30.0f</div>
<br>
<hr><div class = "cent">
<h2>Step II : -On options</h2>
</div>
<p>The second step that we took towards optimization is invoking the various optimization flags (-On) that are offered by gnu g++ compiler. We tried the -On option with n varing from 1 to 4. As described by the profile data shown in Figure 1,2,3 and 4, we took the following inferences from it : </p>
<ol>
<li>
	The cumlative time was least for -O2 option (0.16 units) as compared to that of -O1(0.22 units), -O3(0.28 units) and -O4(0.27 units). Here 1 unit is 0.01 seconds </li>
<li>
	The most time taking functions i.e. b2ContactSolver::SolveVelocityConstraints() and b2RevoluteJoint:: SolvePositionConstraints(b2SolverData const\&) were taking least time with -O2 optimization flag (0.04 units for both) as compared to -O3 (0.06 units), -O4 (0.10 units) and -O1 (0.06 units) </li>
</ol>
<div class = "cent">
<img src="./../doc/images/o1.png" align="middle"height="400px" width="800px"> <br>
Figure 4: Profile data with -O1 option</div>
<br>
<div class = "cent">
<img src="./../doc/images/o2.png" align="middle"height="400px" width="800px"> <br>
Figure 5: Profile data with -O2 option</div>
<br>
<div class = "cent">
<img src="./../doc/images/o3.png" align="middle"height="400px" width="800px"> <br>
Figure 6: Profile data with -O3 option</div>
<br>
<div class = "cent">
<img src="./../doc/images/o4.png" align="middle"height="400px" width="800px"> <br>
Figure 7: Profile data with -O4 option</div>
<br>
<hr><div class = "cent">
<h2>Call graph using python script</h2>
</div>
<p>The callgraph of the final profile is given in the figure below. This is generated by the gprof2dot python jos </p>
<hr><div class = "cent">
<h2>Debug Profile</h2>
</div>
<p>The call graphs generated in the debug profile are : </p>
<div class = "cent">
<img src="./../doc/images/s1.png" align="middle"height="400px" width="800px"> <br>
Part 1: Call Graph for Debug mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/s2.png" align="middle"height="400px" width="800px"> <br>
Part 2: Call Graph for Debug mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/s3.png" align="middle"height="400px" width="800px"> <br>
Part 3: Call Graph for Debug mode</div>
<br>
<hr><div class = "cent">
<h2>Release Profile</h2>
</div>
<p>The call graphs generated in the release profile are : </p>
<div class = "cent">
<img src="./../doc/images/f1.png" align="middle"height="400px" width="800px"> <br>
Part 1: Call Graph for Release mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/f2.png" align="middle"height="400px" width="800px"> <br>
Part 2: Call Graph for Release mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/f3.png" align="middle"height="400px" width="800px"> <br>
Part 3: Call Graph for Release mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/f4.png" align="middle"height="400px" width="800px"> <br>
Part 4: Call Graph for Release mode</div>
<br>
<div class = "cent">
<img src="./../doc/images/f5.png" align="middle"height="400px" width="800px"> <br>
Part 5: Call Graph for Release mode</div>
<br>
<hr><div class = "cent">
<h2>Interesting Features of design</h2>
</div>
<p>One of the major problems we encountered was to build a tight chain structure (i.e. without slacks in between) as it had to take a circular shape. In this case we used the box2D property that two similar type of dynamic bodies (b2DynamicBody) collide by default and push away each other. Due to this property, the chain get automatically fits over the pedal and gear system although it is given a linear shape initially. Gear Mechanism Most interesting and complex part of our simulation is gear mechanism, where in real-type we can change cycle gear and reshape rear-axle with the help of flexible rod and small pully structure. We succeeded in making a gear mechanism similar to real world by using rod and small pully structure. Suspension DistanceJoint feature of Box2D simplified the suspension mechanism.We joined the driver body parts with cycle using distancejoints where using damping ratio and frequency property to ensure that driver undergoes dampening oscillatory motion under a sudden jerk and impulse. </p>
		<hr>
	</body>
</html>
